#!/usr/bin/env python

import sys
import argparse
from glob import glob
from torque_accounting import parser
import pprint
import re
from datetime import datetime, timedelta

global printfmt
printfmt = "%10s %10s  %7s  %5s  %19s  %12s %12s"



def print_job(name,job):
    try:
        jid = (name[:8]+"..") if len(name)>10 else name
        user=job['user']
        user = (user[:8]+"..") if len(user)>10 else user
        queue = job['queue']
        queue = (queue[:5]+"..") if len(queue)>7 else queue
        queuet=job['events']['Q']
        start=job['events']['S']
        endt=job['events']['E']
        wait_time=job['wait_time']
        run_time=job['run_time']
        nodect=job['Resource_List.nodect']
        #print printfmt % (jid,user,queue,nodect,queuet,start,endt,wait_time,run_time)
        print printfmt % (jid,user,queue,nodect,start,wait_time,run_time)
    except KeyError:
        pass

def filter_by_user(username,jobs):
    ujobs={}
    for j in jobs:
        try:
            if jobs[j]['user']==username:
                ujobs[j]=jobs[j]
        except KeyError:
            pass
    return ujobs

def filter_by_queue(queue,jobs):
    qjobs={}
    for j in jobs:
        try:
            if jobs[j]['queue']==queue:
                qjobs[j]=jobs[j]
        except KeyError:
            pass
    return qjobs

def print_nodes(job):
    try:
        print "%s\n" % (job['exec_host'])
    except KeyError:
        print "This job has no exec_host information!"

def print_header():
    print printfmt % ("Job ID","Username","Queue","Nodes", "Start Time","Waiting","Running")
    print printfmt % ("======","========","=====","=====", "==========","=======","=======")

def print_full_job(jobid,jobs):
    for j in jobs:
        if j==jobid or re.match("%s." % (jobid),j):
            pp=pprint.PrettyPrinter(indent=4)
            print "%s:" % (j)
            pp.pprint(jobs[j])
            break

def jobname_to_int(jobname):
    return int(jobname.split('.')[0])

def exechost_to_nodes(exec_host_string):
    nodes=set()
    ehosts=exec_host_string.split('+')
    for eh in ehosts:
        nodes.add(eh.split('/')[0])
    return nodes

def proplist_to_props(proplist):
    properties=set()
    props=proplist.split(':')
    for p in props:
        if not p.isdigit():
            properties.add(p)
    return properties

def print_summary(jobs):
    users={}
    nodes={}
    properties={}
    alljobs=len(jobs)
    jobs_complete=0
    total_job_time=timedelta(0)
    total_node_hours=timedelta(0)
    total_nodes_used = 0
    total_wait_time=timedelta(0)

    for j in jobs:
        try:
            qtime=datetime.strptime(jobs[j]['events']['Q'],"%m/%d/%Y %H:%M:%S")
            start=datetime.strptime(jobs[j]['events']['S'],"%m/%d/%Y %H:%M:%S")
            finish=datetime.strptime(jobs[j]['events']['E'],"%m/%d/%Y %H:%M:%S")
        except:
            continue
        nodelist=exechost_to_nodes(jobs[j]['exec_host'])
        for n in nodelist:
            try:
                nodes[n]['job_count'] += 1
                nodes[n]['job_time'] += (finish-start)
            except KeyError:
                nodes[n] = {}
                nodes[n]['job_count'] = 1
                nodes[n]['job_time'] = finish-start
        try:
            props=proplist_to_props(jobs[j]['Resource_List.neednodes'])
            for p in props:
                try:
                    properties[p] += 1
                except KeyError:
                    properties[p] = 1
        except KeyError:
            pass
                
        u=jobs[j]['user']
        try:
            users[u]['job_count'] += 1
            users[u]['job_time'] += (finish-start)
            users[u]['node_time'] += int(jobs[j]['Resource_List.nodect'])*(finish-start)
            users[u]['node_total'] += int(jobs[j]['Resource_List.nodect'])
            users[u]['queues'].add(jobs[j]['queue'])
            try: 
                users[u]['requests'].append(jobs[j]['Resource_List.neednodes'])
            except:
                pass
        except KeyError:
            users[u]={}
            users[u]['job_count'] = 1
            users[u]['job_time'] = (finish-start)
            users[u]['node_time'] = int(jobs[j]['Resource_List.nodect'])*(finish-start)
            users[u]['node_total'] = int(jobs[j]['Resource_List.nodect'])
            users[u]['queues'] = set()
            users[u]['queues'].add(jobs[j]['queue'])
            users[u]['requests'] = []
            try:
                users[u]['requests'].append(jobs[j]['Resource_List.neednodes'])
            except:
                pass
        jobs_complete += 1
        total_job_time += (finish-start)
        total_nodes_used += int(jobs[j]['Resource_List.nodect'])
        total_node_hours += int(jobs[j]['Resource_List.nodect'])*(finish-start)
        total_wait_time += (start-qtime)
        

    print "-----------------------------"
    print "Total jobs: %d" % alljobs
    print "Total jobs completed: %d" % jobs_complete
    print "Total job time: %s" % parser.strfdelta(total_job_time,"{days}:{hours}:{minutes}:{seconds}")
    print "Total node time used: %s" % parser.strfdelta(total_node_hours,"{days}:{hours}:{minutes}:{seconds}")
    print "Number of users: %d" % len(users)
    print "Number of nodes used: %d" % len(nodes)
    print " "
    print "Average nodes per job: %2.2f" % (float(total_nodes_used)/int(jobs_complete))
    print "Average wallclock time: %s" % parser.strfdelta( total_job_time/jobs_complete, "{days}:{hours}:{minutes}:{seconds}")
    print "Average node time: %s" % parser.strfdelta( total_node_hours/jobs_complete, "{days}:{hours}:{minutes}:{seconds}")
    print "Average waiting time: %s" % parser.strfdelta( total_wait_time/jobs_complete, "{days}:{hours}:{minutes}:{seconds}")
    print " "
    print "-----------------------------"
    propfmt = "%8s - %6s"
    print propfmt % ("PROPERTY","COUNT")
    print propfmt % ("========","=====")
    for p in sorted(properties, key=lambda x: properties[x], reverse=True):
        print propfmt % (p, properties[p])
    print "-----------------------------"
    print "USERS"
    newfmt = "%15s - %4s - %10s - %10s - %13s - %20s"
    print newfmt % ("USER","JOBS","JOB TIME","NODE TIME","AVG NODES/JOB","QUEUES")
    print newfmt % ("====","====","========","=========","=============","======")
    for u in sorted(users):
        print newfmt % ( u, str(users[u]['job_count']),
            parser.strfdelta(users[u]['job_time'],"{days}:{hours}:{minutes}:{seconds}"),
            parser.strfdelta(users[u]['node_time'],"{days}:{hours}:{minutes}:{seconds}"),
            str( float(users[u]['node_total'])/users[u]['job_count'] ),
            ",".join(users[u]['queues']) )
        if len(users[u]['requests'])>0:
            print "Request types: %s\n" % " ; ".join(set(users[u]['requests']))
    print "-----------------------------"
    print "NODES"
    nodefmt = "%15s - %4s - %10s"
    print nodefmt % ("NODE","JOBS","JOB TIME")
    print nodefmt % ("====","====","========")
    for n in sorted(nodes, key=lambda x: nodes[x]['job_count'], reverse=True):
        print nodefmt % (n, str(nodes[n]['job_count']), 
        parser.strfdelta(nodes[n]['job_time'],"{days}:{hours}:{minutes}:{seconds}"))


#    print "DEBUG"
#    print total_job_time
#    print total_node_hours
#    print users



################################# Main ##################################################

ap = argparse.ArgumentParser()
ap.add_argument("--username","-u",dest="username",action="store",required=False,help="Show only jobs for this username")
ap.add_argument("--queue","-q",dest="queue",action="store",required=False,help="Show only jobs for this queue")
ap.add_argument("--job","-j",dest="job",action="store",required=False,help="Show only this job ID in full")
ap.add_argument("--print-nodes","-n",dest="nodes",action="store_true",required=False,default=False,help="Print full node list used for each job")
ap.add_argument("--files","-f",dest="files",nargs='+',action="store",required=False,help="Use the accounting records in these files",
    default = glob('/var/spool/torque/server_priv/accounting/*'))
ap.add_argument("--statistics","-s",dest="summarize",action="store_true",required=False,default=False,help="Print utilization statistics")

args=ap.parse_args()

jobs = parser.parse_files(args.files)

if args.job:
    print_full_job(args.job,jobs)
    sys.exit(0)
if args.username:
    jobs=filter_by_user(args.username,jobs)
if args.queue:
    jobs=filter_by_queue(args.queue,jobs)

if args.summarize:
    print_summary(jobs)
    sys.exit(0)

print_header()
for j in sorted(jobs.iterkeys(),key=jobname_to_int):
    print_job(j,jobs[j])
    if args.nodes:
        print_nodes(jobs[j])


